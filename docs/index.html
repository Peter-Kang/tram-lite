<!DOCTYPE html>
<html lang="en">
	<head>
		<meta name="viewport" content="initial-scale=1.0, maximum-scale=0.5, width=device-width" />
		<meta charset="utf-8" />

		<!-- font -->
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Poppins:wght@200;400;700&family=Ubuntu+Mono&display=swap"
			rel="stylesheet"
		/>

		<!-- icon font -->
		<link
			rel="stylesheet"
			href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0"
		/>

		<!-- open props -->
		<link rel="stylesheet" href="https://unpkg.com/open-props" />
		<link rel="stylesheet" href="https://unpkg.com/open-props/normalize.min.css" />

		<!-- Tram-Lite and Javascript -->
		<script src="https://unpkg.com/tram-lite@2"></script>
		<script src="./main.js"></script>
		<link rel="stylesheet" type="text/css" href="./styles.css" />

		<!-- Title -->
		<title>Tram-Lite</title>

		<!-- Favicon -->
		<link rel="icon" type="image/png" href="https://unpkg.com/@tram-one/tram-logo@5.0.1/dist/lite_32.png" />

		<!-- Social Media Meta Tags -->
		<meta property="og:title" content="Tram-Lite" />
		<meta property="og:url" content="https://tram-one.io/tram-lite/" />
		<meta property="og:image" content="https://tram-one.io/tram-lite/preview.png" />
	</head>
	<body>
		<img id="logo" src="https://unpkg.com/@tram-one/tram-logo@5.0.1/dist/lite.svg" />
		<top-nav>
			<a href="https://tram-one.io/tram-lite/">Tram-Lite</a>
			<a href="https://github.com/Tram-One/tram-lite">Github</a>
			<a href="https://discord.gg/dpBXAQC">Discord</a>
			<a href="https://codepen.io/pen?template=eYQdVao">CodePen</a>
		</top-nav>
		<side-nav>
			<a href="#about">About</a>
			<a href="#install">Install</a>
			<a>API</a>
			<side-nav-section>
				<a href="#define"><code>define</code></a>
				<a href="#html"><code>html</code></a>
				<a href="#queryAllDOM"><code>queryAllDOM</code></a>
				<a href="#addAttributeListener"><code>addAttributeListener</code></a>
			</side-nav-section>
			<a href="#guiding-principles">Guiding Principles</a>
			<a href="#cheat-sheet">Cheat Sheet</a>
		</side-nav>
		<main>
			<page id="about">
				<h1>Tram-Lite</h1>

				<p>Vanilla javascript library for building native web-components!</p>

				<p>
					Tram-Lite is a library that helps developers build native web-components, and makes crafting simple vanilla
					no-build web applications easier, simple, and fun!
				</p>

				<tram-code
					code="
					define`
						<custom-title color='blue'>
							<style>
								h1 { color: ${'color'} }
							</style>

							<h1>${'title'}</h1>
						</custom-title>
					`;"
				></tram-code>

				<h2>API</h2>
				<p>
					Tram-Lite is a small library with a few functions all focused on building and interfacing with native
					web-components.
				</p>
				<p>
					While Tram-Lite's <code>define</code> function is the most unique, all the functions provided in Tram-Lite
					work independently, and can help interact with web components and other elements, regardless of whether they
					were built with Tram-Lite or not.
				</p>

				<dl>
					<dt>
						<a href="#define"><code>define</code></a>
					</dt>
					<dd><p>Template tag function for building native web-components.</p></dd>
					<dt>
						<a href="#html"><code>html</code></a>
					</dt>
					<dd><p>Template tag function for building HTML elements in javascript</p></dd>
					<dt>
						<a href="#queryAllDOM"><code>queryAllDOM</code></a>
					</dt>
					<dd><p>Function for querying elements between light and shadow DOM</p></dd>
					<dt>
						<a href="#addAttributeListener"><code>addAttributeListener</code></a>
					</dt>
					<dd><p>Function to set up a callback for when an element's attribute changes</p></dd>
				</dl>
			</page>
			<page id="install">
				<h2>Install</h2>
				<p>Tram-Lite is easy to include in any project, and requires no build tooling!</p>

				<h2>script tag</h2>
				<p>To install, you can include a script tag pointed to unpkg.com in your <code>index.html</code>:</p>

				<tram-code code=" <script src='https://unpkg.com/tram-lite@2'></script> "> </tram-code>

				<p>
					This will automatically add all the API method to your javascript project. They are attached to the window
					object, and also available via the <code>TramLite</code> object.
				</p>

				<h2>types</h2>

				<p>
					If you use npm, you can get the type definitions by installing <code>tram-lite</code>, even if you don't use
					any build tooling (make sure this matches your script tag above).
				</p>

				<tram-code code=" npm i tram-lite "></tram-code>

				<p>
					This will automatically annotate Tram-Lite methods with documentation in your project if you are using a
					Typescript-aware editor (like Visual Studio Code).
				</p>
			</page>
			<page id="define">
				<h2><code>define</code></h2>
				<section>
					<p><code>define</code> is a template tag function used to create new web-components.</p>
					<tram-code
						code="
						define`
							<my-greeting>
								<h1>Hello ${'name'}</h1>
							</my-greeting>
						`;
					"
					></tram-code>
					<p>
						The outer-most tag in the template will be the new component that is defined (
						<code>&lt;my-greeting&gt;</code> in the above case), and anything under that will be created as shadow-dom
						inside the new web-component.
					</p>
					<p>
						This can be created using <code>document.createElement</code>, the Tram-Lite <code>html</code> function, or
						as part of your HTML template.
					</p>
					<tram-code
						code="
						<body>
							<my-greeting name='Jesse'></my-greeting>
						</body>
					"
					></tram-code>
					<p>
						Any templated strings (for example, <code>${'name'}</code>) will become observed attributes on the new
						component. If you want to change them, you can use the native <code>setAttribute</code> function.
					</p>
					<tram-code
						code="
						const greeting = document.querySelector('my-greeting');
						greeting.setAttribute('name', 'Tina')
					"
					></tram-code>
					<p>
						Additionally, you can include script tags that reference <code>this</code>. When the component is mounted,
						the script tag will run, and <code>this</code> will refer to the newly mounted instance.
					</p>
					<tram-code
						code="
						define`
							<my-greeting>
								<h1>Hello ${'name'}</h1>
								<script>capitalizeGreetingName(this)</script>
							</my-greeting>
						`;

						function capitalizeGreetingName(greeting) {
							name = greeting.getAttribute('name');
							greeting.setAttribute('name', name.toUpperCase())
						}
					"
					></tram-code>
				</section>
				<section>
					<h2>Syntax</h2>
					<tram-code
						code="
						define`
							<tag-name default-attributes='default value'>
								<h1>Template</h1>
								<p>${'template-variables'}</p>
							</tag-name>
						`;
					"
					></tram-code>
					<h3>Parameters</h3>
					<dl>
						<dt><code>tag name</code></dt>
						<dd>
							<p>
								the name of the new custom component. this is defined in the outer most tag, and must be a hyphenated
								string
							</p>
						</dd>
						<dt><code>default attributes</code> <optional-badge>optional</optional-badge></dt>
						<dd>
							<p>
								attributes defined in the outer-most tag, these are the default values when the component is mounted
								without supplied values
							</p>
						</dd>
						<dt><code>template</code></dt>
						<dd>
							<p>
								any DOM inside the outer most tag, this template that will be injected as shadow DOM on mounting the
								component
							</p>
						</dd>
						<dt><code>template variables</code> <optional-badge>optional</optional-badge></dt>
						<dd>
							<p>
								any string variables in the template will become attributes for the component. When these attributes are
								updated, it will trigger specific updates in specific spots in the DOM
							</p>
						</dd>
					</dl>
					<h3>Return Value</h3>
					<p>None</p>
					<h3>Exceptions</h3>
					<dl>
						<dt>Element Definition Errors</dt>
						<dd>
							<p>
								Any errors that can occur from creating custom components, (<a
									href="https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/define#exceptions"
									>see on MDN</a
								>)
							</p>
						</dd>
					</dl>
				</section>
			</page>
			<page id="html">
				<h2><code>html</code></h2>
				<section>
					<p>
						<code>html</code> is a template tag function to quickly create html dom with all their attributes and
						content.
					</p>
					<tram-code
						code="
						const pageHeader = html`<h1>Hello World</h1>`;
						document.body.appendChild(pageHeader);
					"
					></tram-code>
					<p>
						This can help reduce the amount of code needed when building components in javascript, removing the need for
						chains of
						<code>document.createElement</code>, <code>setAttribute</code>, and setting <code>innerHTML</code> or
						<code>innerText</code>.
					</p>
				</section>
				<section>
					<h2>Syntax</h2>
					<tram-code code="html`template`"></tram-code>
					<h3>Parameters</h3>
					<dt><code>template</code></dt>
					<dd>
						<p>any HTML DOM, with props, inner HTML and inner text.</p>
					</dd>
					<h3>Return Value</h3>
					<p>
						The template as an <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element">Element</a>, or null
						if the template is invalid
					</p>
					<h3>Exceptions</h3>
					<dl>
						<dt>N/A</dt>
					</dl>
				</section>
			</page>
			<page id="queryAllDOM">
				<h2><code>queryAllDOM</code></h2>
				<section>
					<p><code>queryAllDOM</code> is a helper function to easily query across shadow and light DOM boundaries.</p>
					<p>
						This is useful when nesting multiple components inside of each other, as the native
						<code>querySelector</code> methods won't between shadow and light DOM.
					</p>
				</section>
				<section>
					<h2>Syntax</h2>
					<tram-code
						code="
							queryAllDOM(selector)
							queryAllDOM(selector, root)
						"
					></tram-code>
					<h3>Parameters</h3>
					<dl>
						<dt><code>selector</code></dt>
						<dd><p>A valid CSS selector to search through the shadow and light DOM for.</p></dd>
						<dt><code>root</code> <optional-badge>optional</optional-badge></dt>
						<dd>
							<p>The root element to start searching for. This defaults to the <code>document</code>.</p>
						</dd>
					</dl>
					<h3>Return Value</h3>
					<p>
						A list of Elements that match the <code>selector</code>, starting from the <code>root</code> (or
						<code>document</code> by default)
					</p>
					<h3>Exceptions</h3>
					<dl>
						<dt><code>SyntaxError</code> <code>DOMException</code></dt>
						<dd>Thrown if the syntax of the specified selectors is invalid.</dd>
						<dt><code>TypeError</code></dt>
						<dd>Thrown if the root node passed in does not have a <code>querySelectorAll</code> method</dd>
					</dl>
				</section>
				<section>
					<h2>Example</h2>
					<p>Let's assume the document body looks like the following:</p>
					<tram-code
						code="
							<custom-list>
								#shadow-root
									<ul>
										<custom-list-item>
											#shadow-root
												<li>First Item</li>
										</custom-list-item>
									</ul>
							</custom-list>
						"
					></tram-code>
					<p>You could use <code>queryAllDOM</code> to get the <code>li</code> tag in the deeply nested DOM</p>
					<tram-code
						code="
							const listItems = queryAllDOM('li');
							// returns [<li>First Item</li>]
						"
					></tram-code>
				</section>
			</page>
			<page id="addAttributeListener">
				<h2><code>addAttributeListener</code></h2>
				<section>
					<p>
						<code>addAttributeListener</code> is a helper function to set up a callback for when an element's attribute
						changes.
					</p>
					<p>This allows your component to react more dynamically to attribute changes (beyond simple templating).</p>
				</section>
				<section>
					<h2>Syntax</h2>
					<tram-code
						code="
						addAttributeListener(element, attributeName, callback)
					"
					></tram-code>
					<h3>Parameters</h3>
					<dl>
						<dt><code>element</code></dt>
						<dd><p>Element to watch attribute changes for.</p></dd>
						<dt><code>attributeName</code></dt>
						<dd><p>The attribute name on the element to watch changes for.</p></dd>
						<dt><code>callback</code></dt>
						<dd>
							<p>The function to call when the attribute changes. It has the following parameters:</p>
							<dl>
								<dt><code>mutationRecord</code></dt>
								<dd>
									A
									<a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord"
										><code>MutationRecord</code></a
									>
									object for the change that was triggered.
								</dd>
							</dl>
						</dd>
					</dl>
					<h3>Return Value</h3>
					<p>None</p>
					<h3>Exceptions</h3>
					<p>To Be Added...</p>
				</section>
				<section>
					<h2>Example</h2>
					<tram-code
						code="
							const alertingCount = html`
								<test-counter count='4'></test-counter>
							`;

							// setup observer
							addAttributeListener(alertingCount, 'count', () => {
								console.log(`Count: ${alertingCount.getAttribute('count')}`);
							});

							// update count, which will trigger the alert
							alertingCount.setAttribute('count', '5');
						"
					></tram-code>
				</section>
			</page>
			<page id="guiding-principles">
				<h2>Guiding Principles</h2>
				<p>
					The following are principles that motivate the design philosophy around the interface and methods found in the
					Tram-Lite library.
				</p>

				<h2>1. Not a Framework</h2>
				<p>
					Tram-Lite is a <b>library</b>, it is <b>not a framework</b>. As much as possible, users should run and
					orchestrate their own code. In the face of bloat and tradeoffs associated with frameworks, and the difficulty
					associated with learning new syntax and data models, we'd like Tram-Lite to be a simple alternative. With
					respect to the <a href="https://github.com/frameworkless-movement/manifesto">Frameworkless Manifesto</a>, we
					believe that Tram-Lite can be an alternative that offers few tradeoffs, and seamless integration with other
					libraries or frameworks.
				</p>
				<p>
					In practice, this means that Tram-Lite is not an all encompassing framework that you tie all functions and
					state to. Tram-Lite does not heavily bind itself into the window object (save for exposing its own functions),
					and does not attach listeners or cause other non-obvious side-effects to the browser.
				</p>
				<p><b> This is the main guiding principle that inspires all others. </b></p>
				<h2>2. Defer to native APIs</h2>
				<p>
					Tram-Lite should strive to only offer functions when they would offer substantial benefit over native existing
					options. This could be because the existing options are tedious (as is the case for
					<code>.createElement()</code> and <code>.setAttribute()</code>), or because the existing option is complex (as
					is the case for creating new web-components).
				</p>
				<p>
					Conversely, functionality that would be traditionally rare, or already has native solutions, should be
					avoided.
				</p>
				<h2>3. Interoperable and optional</h2>
				<p>
					Tram-Lite functions should never depend on each other. While we may offer functions that help enable patterns
					created as a side effect of other elements in the Tram-Lite library, they should be functional in an
					environment where no other Tram-Lite functions are being used.
				</p>
				<p>
					To this end, all functions that are generative should expose objects with common and native interfaces. This
					means any additional functions that mean to target these objects, should work with other non-Tram-Lite
					elements.
				</p>
				<h2>4. Favor no-build environments</h2>
				<p>
					Tram-Lite's target environment is a basic html file. It should offer everything needed, and let developers
					build immediately, with no other tools or libraries required.
				</p>
				<p>
					While many frameworks will recommend generators or platforms for an optimal development experience, we should
					strive to make the vanilla javascript experience ideal, where only a static web host may be available.
				</p>
				<p>
					To this end, while we should be interoperable with other libraries, we should not be totally contingent on
					other libraries to provide a delightful experience.
				</p>
				<p>
					<em>
						Additionally, as much as possible, this project should try to adhere to this principle as much as possible.
					</em>
				</p>
			</page>
			<page id="cheat-sheet">
				<h2>Cheat Sheet</h2>
				<p>Section under construction...</p>
			</page>
		</main>
	</body>
</html>
